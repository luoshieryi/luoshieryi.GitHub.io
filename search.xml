<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Brew 安装 anaconda</title>
      <link href="/2023/07/05/brew-an-zhuang-anaconda-bing-jian-dan-pei-zhi/"/>
      <url>/2023/07/05/brew-an-zhuang-anaconda-bing-jian-dan-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="Brew-安装-anaconda"><a href="#Brew-安装-anaconda" class="headerlink" title="Brew 安装 anaconda"></a>Brew 安装 anaconda</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 直接安装 anacondabrew install anaconda# zsh 配置环境变量echo &#39;export PATH&#x3D;&quot;&#x2F;opt&#x2F;homebrew&#x2F;anaconda3&#x2F;bin:$PATH&quot;&#39; &gt;&gt; ~&#x2F;.zshrcsource ~&#x2F;.zshrc# conda 初始化conda init zsh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 bash 则将相应的文件&#x2F;命令换为 bash(.bash_profile)</p><h1 id="anaconda-配置-python-环境"><a href="#anaconda-配置-python-环境" class="headerlink" title="anaconda 配置 python 环境"></a>anaconda 配置 python 环境</h1><pre><code class="shell"># 查看 conda 版本conda --version# 创建环境conda create -n $env_name python=$python_version $dependencies# 列出当前环境conda env list# 切换环境conda activate $env_name# 删除环境conda remove -n $env_name --all# 列出安装的包conda list# 更新所有包conda update --all#卸载包conda uninstall $package_name</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> zsh </tag>
            
            <tag> homebrew </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-compose 部署 SpringCloud services + nacos +mysql8</title>
      <link href="/2022/06/20/docker-compose-bu-shu-springcloud-services-nacos-mysql8/"/>
      <url>/2022/06/20/docker-compose-bu-shu-springcloud-services-nacos-mysql8/</url>
      
        <content type="html"><![CDATA[<h1 id="docker-compose-一键部署-SpringCloud-services-nacos-mysql8-的疑难杂症"><a href="#docker-compose-一键部署-SpringCloud-services-nacos-mysql8-的疑难杂症" class="headerlink" title="docker-compose 一键部署 SpringCloud services + nacos + mysql8 的疑难杂症"></a>docker-compose 一键部署 SpringCloud services + nacos + mysql8 的疑难杂症</h1><h6 id="about"><a href="#about" class="headerlink" title="about"></a>about</h6><ul><li>nacos-server 版本为 2.1.0 , 完全兼容 spring cloud alibaba 2021.0.1.0 版本对应的 nacos-client:v1.4.3</li><li>完整项目见: <a href="https://github.com/luoshieryi/springCloud-learn1">https://github.com/luoshieryi/springCloud-learn1</a></li></ul><h2 id="遇到的问题与解决方案"><a href="#遇到的问题与解决方案" class="headerlink" title="遇到的问题与解决方案"></a>遇到的问题与解决方案</h2><h3 id="1-抽象出的-feign-client-子模块没有-Application-java-类-导致无法编译-x2F-引入"><a href="#1-抽象出的-feign-client-子模块没有-Application-java-类-导致无法编译-x2F-引入" class="headerlink" title="1. 抽象出的 feign-client 子模块没有 Application.java 类, 导致无法编译&#x2F;引入"></a>1. 抽象出的 feign-client 子模块没有 Application.java 类, 导致无法编译&#x2F;引入</h3><p>在该模块 pom.xml 的 spring-boot-maven-plugin 中添加如下配置:</p><ul><li>没有第一条配置无法编译</li><li>没有第二条配置无法被其他包引入</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span><span class="token punctuation">></span></span>NONE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!--让maven不打包可执行jar，不扫描项目的main函数--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classifier</span><span class="token punctuation">></span></span>exec<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classifier</span><span class="token punctuation">></span></span> <span class="token comment">&lt;!--普通jar和可执行jar不同名，普通jar为xx.jar ， 可执行jar为 xx-exec.jar--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-dev-与-prod-环境时不同的-mysql-nacos地址"><a href="#2-dev-与-prod-环境时不同的-mysql-nacos地址" class="headerlink" title="2. dev 与 prod 环境时不同的 mysql, nacos地址"></a>2. dev 与 prod 环境时不同的 mysql, nacos地址</h3><ol><li>使用 spring.profiles.active 参数来指定 dev 和 prod 环境</li><li>在 Dockerfile 中运行jar时: ENTRYPOINT java -jar &#x2F;app&#x2F;app.jar –spring.profiles.active&#x3D;prod</li></ol><h3 id="3-同一个-docker-compose-中-通过-hostname-访问-nacos-失败"><a href="#3-同一个-docker-compose-中-通过-hostname-访问-nacos-失败" class="headerlink" title="3. 同一个 docker-compose 中, 通过 hostname 访问 nacos 失败"></a>3. 同一个 docker-compose 中, 通过 hostname 访问 nacos 失败</h3><ul><li>“Connection refused”</li><li>关联 issue: <a href="https://github.com/alibaba/nacos/issues/7298">https://github.com/alibaba/nacos/issues/7298</a></li></ul><p>显式手动设置 hostname : 在 docker-compose.yml 中添加如下配置:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">services:  nacos:    hostname: nacos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-在-mysql-中初始化数据库用户和数据库"><a href="#4-在-mysql-中初始化数据库用户和数据库" class="headerlink" title="4. 在 mysql 中初始化数据库用户和数据库"></a>4. 在 mysql 中初始化数据库用户和数据库</h3><ul><li>映射sql文件到容器的 &#x2F;docker-entrypoint-initdb.d&#x2F; 文件夹中, 会自动按名称顺序执行语句</li><li>可以在 environment 中添加用户( 官网 nacos.io 的示例docker部署采用)<pre class="line-numbers language-env" data-language="env"><code class="language-env">MYSQL_USER&#x3D;nacosMYSQL_PASSWORD&#x3D;nacos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="5-“currentServerAddr-http-localhost-8848-err-Connection-refused”"><a href="#5-“currentServerAddr-http-localhost-8848-err-Connection-refused”" class="headerlink" title="5. “currentServerAddr: http://localhost:8848, err : Connection refused”"></a>5. “currentServerAddr: <a href="http://localhost:8848/">http://localhost:8848</a>, err : Connection refused”</h3><ul><li>“java.net.ConnectException: [NACOS HTTP-POST] The maximum number of tolerable server reconnection errors has been reached”</li><li>关联 issue: <a href="https://github.com/alibaba/spring-cloud-alibaba/issues/1599">https://github.com/alibaba/spring-cloud-alibaba/issues/1599</a></li></ul><p>项目引入了 spring-cloud-starter-alibaba-nacos-config 依赖, 但是又没有使用它提供的动态配置功能</p><h3 id="6-关于MySQL-8-的-“Public-Key-Retrival”-错误"><a href="#6-关于MySQL-8-的-“Public-Key-Retrival”-错误" class="headerlink" title="6. 关于MySQL 8 的 “Public Key Retrival” 错误"></a>6. 关于MySQL 8 的 “Public Key Retrival” 错误</h3><p>添加 allowPublicKeyRetrieval&#x3D;true 到 jdbc 连接串中</p><ul><li>详解: <a href="https://blog.csdn.net/qq_41287877/article/details/89818095">https://blog.csdn.net/qq_41287877/article/details/89818095</a></li></ul><h2 id="部署步骤与-docker-配置"><a href="#部署步骤与-docker-配置" class="headerlink" title="部署步骤与 docker 配置"></a>部署步骤与 docker 配置</h2><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ol><li>使用 maven 打包父项目</li><li>运行 <code>docker-compose up -d</code></li></ol><h3 id="配置源码"><a href="#配置源码" class="headerlink" title="配置源码"></a>配置源码</h3><h4 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">version: &quot;3.8&quot;services:  learn1-nacos:    container_name: learn1-nacos    hostname: learn1-nacos    image: nacos&#x2F;nacos-server:v2.1.0    env_file:      - .&#x2F;docker&#x2F;env&#x2F;nacos.env    volumes:      - .&#x2F;docker&#x2F;nacos&#x2F;logs&#x2F;:&#x2F;home&#x2F;nacos&#x2F;logs#      - .&#x2F;docker&#x2F;nacos&#x2F;custom.properties:&#x2F;home&#x2F;nacos&#x2F;init.d&#x2F;custom.properties    ports:      - &quot;8848:8848&quot;      - &quot;9848:9848&quot;      - &quot;9555:9555&quot;    depends_on:      - learn1-mysql    restart: always  learn1-mysql:    container_name: learn1-mysql    image: mysql:8.0.29    env_file:      - .&#x2F;docker&#x2F;env&#x2F;mysql.env    volumes:      - .&#x2F;docker&#x2F;mysql&#x2F;data&#x2F;:&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;      - .&#x2F;docker&#x2F;mysql&#x2F;initdb&#x2F;:&#x2F;docker-entrypoint-initdb.d&#x2F;    ports:      - &quot;3306:3306&quot;    cap_add:      - SYS_NICE    restart: always  learn1-user-service:    container_name: learn1-user-service    build: .&#x2F;user-service    depends_on:      - learn1-nacos    restart: always  learn1-order-service:    container_name: learn1-order-service    build: .&#x2F;order-service    depends_on:      - learn1-nacos    restart: always  learn1-gateway:    container_name: learn1-gateway    build: .&#x2F;gateway    ports:      - &quot;10010:10010&quot;    depends_on:      - learn1-nacos    restart: always<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="env"><a href="#env" class="headerlink" title=".env"></a>.env</h4><p>docker-compose.yml 中的 env_file 配置的文件</p><ul><li>nacos.env  <pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">PREFER_HOST_MODE&#x3D;hostnameMODE&#x3D;standaloneMYSQL_SERVICE_HOST&#x3D;mysqlMYSQL_SERVICE_DB_NAME&#x3D;nacosMYSQL_SERVICE_PORT&#x3D;3306MYSQL_SERVICE_USER&#x3D;nacosMYSQL_SERVICE_PASSWORD&#x3D;nacosMYSQL_SERVICE_DB_PARAM&#x3D;characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true&amp;useSSL&#x3D;false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>mysql.env<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">MYSQL_ROOT_PASSWORD&#x3D;root  MYSQL_USER&#x3D;nacos  MYSQL_PASSWORD&#x3D;nacos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>在需要部署的项目下创建 Dockerfile 文件</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">FROM java:8-alpineCOPY .&#x2F;target&#x2F;app.jar &#x2F;app&#x2F;app.jarENTRYPOINT java -jar &#x2F;app&#x2F;app.jar --spring.profiles.active&#x3D;prod<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h4><ul><li><p>nacos.sql : 在官方提供的建表文件前添加数据库与用户的配置</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create database nacos character set utf8 collate utf8_general_ci;grant all on nacos.* to &#39;nacos&#39;@&#39;%&#39;;use nacos;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>nacos 建表语句: <a href="https://github.com/alibaba/nacos/blob/master/distribution/conf/nacos-mysql.sql">https://github.com/alibaba/nacos/blob/master/distribution/conf/nacos-mysql.sql</a></li></ul></li><li><p>其他项目 sql 见最上方的仓库地址</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> docker </tag>
            
            <tag> springcloud </tag>
            
            <tag> nacos </tag>
            
            <tag> mysql8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask 跨域资源共享</title>
      <link href="/2022/04/20/flask-kua-yu-zi-yuan-yun-xu/"/>
      <url>/2022/04/20/flask-kua-yu-zi-yuan-yun-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="flask-跨域资源共享"><a href="#flask-跨域资源共享" class="headerlink" title="flask 跨域资源共享"></a>flask 跨域资源共享</h1><p>最近完成 python 实验尝试使用了 flask 作为后端框架, 第一次用这么轻的框架从零开始搭建项目, 遇到了一点跨域上的小问题</p><h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h2><blockquote><p>Flask is a lightweight <a href="https://wsgi.readthedocs.io/">WSGI</a> web application framework. It is designed to make getting started quick and easy, with the ability to scale up to complex applications. It began as a simple wrapper around <a href="https://werkzeug.palletsprojects.com/">Werkzeug</a> and <a href="https://jinja.palletsprojects.com/">Jinja</a> and has become one of the most popular Python web application frameworks.</p></blockquote><p>flask 是在 github 上有 58k star (2022.04.20) 的开源 python 后端框架, 以超轻量级而出名, 一个用 flask 写的 hello world 甚至只需要五行代码: </p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># save this as app.pyfrom flask import Flaskapp &#x3D; Flask(__name__)@app.route(&quot;&#x2F;&quot;)def hello():    return &quot;Hello, World!&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用这样的 “微框架” 可以更好地了解一些底层原理, 这里记录一次跨域资源请求问题的解决</p><h2 id="CORS-跨源资源共享"><a href="#CORS-跨源资源共享" class="headerlink" title="CORS: 跨源资源共享"></a>CORS: 跨源资源共享</h2><h3 id="涉及跨域资源请求的情景"><a href="#涉及跨域资源请求的情景" class="headerlink" title="涉及跨域资源请求的情景:"></a>涉及跨域资源请求的情景:</h3><ul><li>由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch APIs</a> 发起的跨源 HTTP 请求。</li><li>Web 字体 (CSS 中通过 <code>@font-face</code> 使用跨源字体资源)，<a href="https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements">因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用</a>。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL">WebGL 贴图</a></li><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage"><code>drawImage</code></a> 将 Images&#x2F;video 画面绘制到 canvas。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Shapes/Shapes_From_Images">来自图像的 CSS 图形</a></li></ul><h3 id="三种跨域请求"><a href="#三种跨域请求" class="headerlink" title="三种跨域请求:"></a>三种跨域请求:</h3><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82">简单请求</a></h4><p>( 点击标题查看MDN文档 ↑↑↑ )</p><p>使用 GET&#x2F;POST 方法, 手动设置的 header 字段只有以下四种, 且 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> 的值有额外要求: </p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept"><code>Accept</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language"><code>Accept-Language</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language"><code>Content-Language</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> :<ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul></li></ul><p>此时服务端需要设置 header : <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a> , 为 * 表示允许任意外域访问该资源</p><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82">预检请求</a></h4><p>( 点击标题查看MDN文档 ↑↑↑ )</p><p>非简单请求需要预检, 要求必须首先使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS"><code>OPTIONS</code></a> 方法发起一个预检请求到服务器, 依据服务器是否允许访问该资源决定是否发送实际请求 (通常由浏览器自动发送预检请求)</p><p>预检过程中,  预检请求中会携带了下面两个header : </p><pre class="line-numbers language-none"><code class="language-none">Access-Control-Request-Method: POSTAccess-Control-Request-Headers: X-PINGOTHER, Content-Type<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>分别为 实际请求的Method, 实际请求携带的自定义header字段</p><p>服务器对预检请求做出响应, 在response中需要携带以下header : </p><pre class="line-numbers language-none"><code class="language-none">Access-Control-Allow-Origin: https:&#x2F;&#x2F;foo.exampleAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHER, Content-Type<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>分别为 限制请求的源域, 允许请求的Method, 允许携带的自定义 header</p><p>还可以设置header字段 <code>Access-Control-Max-Age</code> , 表明该预检请求的有效时间, 该时间范围内浏览器不会为同一请求发起预检请求</p><p>预检通过会浏览器才会发送真实请求</p><h4 id="附带身份凭证的请求"><a href="#附带身份凭证的请求" class="headerlink" title="附带身份凭证的请求"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E9%99%84%E5%B8%A6%E8%BA%AB%E4%BB%BD%E5%87%AD%E8%AF%81%E7%9A%84%E8%AF%B7%E6%B1%82">附带身份凭证的请求</a></h4><p>( 点击标题查看MDN文档 ↑↑↑ )</p><p>在需要 基于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">HTTP cookies</a> 和 HTTP 认证信息发送身份凭证 时, 需要将 request 的 <code>withCredentials</code> 标志设为 <code>true</code> , 同时在服务端的 response 中也需要添加header:  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials"><code>Access-Control-Allow-Credentials: true</code></a> </p><h5 id="注意项"><a href="#注意项" class="headerlink" title="! 注意项 ! :"></a>! 注意项 ! :</h5><blockquote><ul><li>服务器不能将 <code>Access-Control-Allow-Origin</code> 的值设为通配符“<code>*</code>”，而应将其设置为特定的域，如：<code>Access-Control-Allow-Origin: https://example.com</code>。</li><li>服务器不能将 <code>Access-Control-Allow-Headers</code> 的值设为通配符“<code>*</code>”，而应将其设置为首部名称的列表，如：<code>Access-Control-Allow-Headers: X-PINGOTHER, Content-Type</code></li><li>服务器不能将 <code>Access-Control-Allow-Methods</code> 的值设为通配符“<code>*</code>”，而应将其设置为特定请求方法名称的列表，如：<code>Access-Control-Allow-Methods: POST, GET</code></li></ul></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-使用flask-CORS"><a href="#1-使用flask-CORS" class="headerlink" title="1. 使用flask-CORS"></a>1. 使用flask-CORS</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from flask_cors import CORSapp &#x3D; Flask(__name__)CORS(app, supports_credentials&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-手写-flask-的-response-拦截器"><a href="#2-手写-flask-的-response-拦截器" class="headerlink" title="2. 手写 flask 的 response 拦截器"></a>2. 手写 flask 的 response 拦截器</h3><p>下边是一个简单的拦截器, 可以接受使用json传输数据的http跨域请求, 具体设置为: </p><ul><li>接受来自任何域的请求</li><li>允许附带身份凭证</li><li>允许的请求方式有: GET, POST, PUT, DELETE</li><li>允许的自定义 header 有: content-type</li><li>允许的 content-type 的值有: application&#x2F;json</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def after_req(resp):    resp.headers[&quot;Access-Control-Allow-Origin&quot;] &#x3D; request.origin    resp.headers[&quot;Access-Control-Allow-Credentials&quot;] &#x3D; &quot;true&quot;    resp.headers[&quot;Access-Control-Allow-Methods&quot;] &#x3D; &quot;GET, POST, PUT, DELETE&quot;    resp.headers[&quot;Access-Control-Allow-Headers&quot;] &#x3D; &quot;content-type&quot;    resp.headers[&quot;content-type&quot;] &#x3D; &quot;application&#x2F;json&quot;    return resp    app.after_request(after_req)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-前端代理"><a href="#3-前端代理" class="headerlink" title="3. 前端代理"></a>3. 前端代理</h3><p>通过设置 axios 的 proxy 选项配置前端的代理服务器，所有请求都发送到同域内的前端服务器，再由前端转发给后端</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> axios <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'axios'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> instance <span class="token operator">=</span> axios<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">baseURL</span><span class="token operator">:</span> <span class="token string">'http://localhost:3000/'</span><span class="token punctuation">,</span>    <span class="token literal-property property">proxy</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">host</span><span class="token operator">:</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span>        <span class="token literal-property property">port</span><span class="token operator">:</span> <span class="token number">9000</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/api/users'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><ul><li>flask-github : <a href="https://github.com/pallets/flask">https://github.com/pallets/flask</a></li><li>flask-document : <a href="https://flask.palletsprojects.com/en/2.1.x/">https://flask.palletsprojects.com/en/2.1.x/</a></li><li>mdn-CORS : <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</a></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> flask </tag>
            
            <tag> http </tag>
            
            <tag> cors </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 3.0 预览</title>
      <link href="/2022/03/02/springboot-3.0-yu-lan/"/>
      <url>/2022/03/02/springboot-3.0-yu-lan/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot-3-0-预览"><a href="#Spring-Boot-3-0-预览" class="headerlink" title="Spring Boot 3.0 预览"></a>Spring Boot 3.0 预览</h1><p>1 月 20 日, Spring 发布了新的 Spring Boot 3.0 里程碑版本 Spring Boot 3.0.0-M1 , 并预计每两月发布一个新的里程碑版本, 11月下旬发布 GA 版本</p><blockquote><p><a href="https://spring.io/blog/2022/01/20/spring-boot-3-0-0-m1-is-now-available">https://spring.io/blog/2022/01/20/spring-boot-3-0-0-m1-is-now-available</a></p></blockquote><h2 id="依赖版本变动"><a href="#依赖版本变动" class="headerlink" title="依赖版本变动"></a>依赖版本变动</h2><blockquote><p>这听起来虽然有些激进，但请注意，我们讨论的是 2022 年第四季度的发布。到那时，JDK 17 早已取代 JDK 11 成为下一个长期支持版本一年多了，而且它本身也将被 JDK 18 和 JDK  19 所取代，作为特性发布版本，它们已经可用了，而且 JDK 20 也接近其功能冻结期。</p><p>对于 Jakarta EE 9 也是如此。我们预计 Jakarta  EE 10 届时业已发布，并且新一代的 Tomcat、Jetty 和其他的运行时方案将会支持它们。保持上述最低限度的基线，可以在 Spring  Framework 6.x 一代中获得进一步的 Java 进化，而 Java 17 和 Jakarta EE 9 只是一个开始。</p></blockquote><h3 id="Java-8-→-Java-17"><a href="#Java-8-→-Java-17" class="headerlink" title="Java 8 → Java 17"></a>Java 8 → Java 17</h3><p>java 17 是 2021.09.14 推出的新 LTS 版本 (Long Term Support) </p><h3 id="Java-EE-→-Jakarta-EE"><a href="#Java-EE-→-Jakarta-EE" class="headerlink" title="Java EE → Jakarta EE"></a>Java EE → Jakarta EE</h3><p>Java EE 在几年前被 Eclipse 基金会改名为 Jakarta EE , 重命名了很多规范</p><ul><li>需要将命名空间 javax 改为 jakarta</li><li>一些依赖Java EE API的第三方库，目前还没有得到很好的支持，在Spring Boot 3中暂时会先移除<br>( 见 <a href="#%E6%9A%82%E6%97%B6%E7%A7%BB%E9%99%A4%E7%9A%84%E4%BE%9D%E8%B5%96">暂时移除的依赖</a> )</li></ul><h3 id="Spring-Framework-5-3-→-6-0"><a href="#Spring-Framework-5-3-→-6-0" class="headerlink" title="Spring Framework 5.3 → 6.0"></a>Spring Framework 5.3 → 6.0</h3><p>预计于 2022.08 发布第一个 GA 版本</p><h4 id="关注点"><a href="#关注点" class="headerlink" title="关注点:"></a>关注点:</h4><p>排除点和变更点</p><ul><li>可能 XML 配置格式会成为过去式。</li><li>一些 Java EE API（ EJB、JCA、JAX-WS）过期。</li><li>RPC 支持（不知道怎么翻译 HTTP Invoker ）过期</li></ul><p>迁移至Jakarta EE 9+</p><ul><li><code>jakarta.servlet</code>(Tomcat 10、Jetty 11相关)。</li><li><code>jakarta.persistence</code>(Hibernate ORM 6?)。</li></ul><p>云原生</p><p>改进对<strong>GraalVM</strong>和<strong>Project Leyden</strong>(一个Java静态图项目)的支持。</p><h4 id="M1-版本特性"><a href="#M1-版本特性" class="headerlink" title="M1 版本特性:"></a>M1 版本特性:</h4><ul><li><p>关于 Commons FileUpload and Tiles, 和 FreeMarker JSP 的集成将被移除</p></li><li><p>@RequestMapping without @Controller registered as handler</p><blockquote><p><a href="https://github.com/spring-projects/spring-framework/issues/22154">https://github.com/spring-projects/spring-framework/issues/22154</a></p></blockquote></li><li><p>HttpMethod 从枚举升级为一个类</p><blockquote><p><a href="https://github.com/spring-projects/spring-framework/issues/27697">https://github.com/spring-projects/spring-framework/issues/27697</a></p></blockquote></li></ul><blockquote><p>更多新特性: <a href="https://github.com/spring-projects/spring-framework/releases/tag/v6.0.0-M1">https://github.com/spring-projects/spring-framework/releases/tag/v6.0.0-M1</a></p></blockquote><h3 id="其他依赖版本升级"><a href="#其他依赖版本升级" class="headerlink" title="其他依赖版本升级"></a>其他依赖版本升级</h3><p>Spring Boot 3.0.0-M1 moves to new versions of several Spring projects:</p><ul><li>Micrometer 2.0.0-M1</li><li>Spring AMQP 3.0.0-M1</li><li>Spring Batch 5.0.0-M1</li><li>Spring Data 2022.0.0-M1</li><li><a href="https://github.com/spring-projects/spring-framework/releases/tag/v6.0.0-M2">Spring Framework 6.0.0-M2</a></li><li>Spring Integration 6.0.0-M1</li><li><a href="https://github.com/spring-projects/spring-hateoas/releases/tag/2.0.0-M1">Spring HATEOAS 2.0.0-M1</a></li><li>Spring Kafka 3.0.0-M1</li><li><a href="https://github.com/spring-projects/spring-ldap/releases/tag/3.0.0-M1">Spring LDAP 3.0.0-M1</a></li><li><a href="https://github.com/spring-projects/spring-restdocs/releases/tag/v3.0.0-M1">Spring REST Docs 3.0.0-M1</a><ul><li>在 M2 版本中升级为 Spring REST Docs 3.0.0-M2</li></ul></li><li><a href="https://github.com/spring-projects/spring-security/releases/tag/6.0.0-M1">Spring Security 6.0.0-M1</a></li><li>Spring Session 2022.0.0-M1</li><li>Spring Web Services 4.0.0-M1</li></ul><p>Numerous third-party dependencies have also been updated, some of the more noteworthy of which are the following:</p><ul><li>Artemis 2.20.0</li><li>Hazelcast 5.0</li><li>Hibernate Validator 7.0</li><li>Jakarta Activation 2.0</li><li>Jakarta Annotation 2.0</li><li>Jakarta JMS 3.0</li><li>Jakarta JSON 2.0</li><li>Jakarta JSON Bind 3.0</li><li>Jakarta Mail 2.0</li><li>Jakarta Persistence 3.0</li><li>Jakarta Servlet 5.0</li><li>Jakarta Servlet JSP JSTL 2.0</li><li>Jakarta Transaction 2.0</li><li>Jakarta Validation 3.0</li><li>Jakarta WebSocket 2.0</li><li>Jakarta WS RS 3.0</li><li>Jakarta XML Bind 3.0</li><li>Jakarta XML Soap 2.0</li><li>Jetty 11</li><li>jOOQ 3.16</li><li>Tomcat 10</li></ul><h2 id="暂时移除的依赖"><a href="#暂时移除的依赖" class="headerlink" title="暂时移除的依赖"></a>暂时移除的依赖</h2><ul><li>EhCache 3 </li><li>H2’s web console<ul><li>已在 M2 版本中恢复</li></ul></li><li>Hibernate’s metrics</li><li>Infinispan</li><li>Jolokia</li><li>Pooled JMS</li><li>REST Assured<ul><li>已在 M2 版本中恢复: REST Assured 4.5</li></ul></li><li>SMTP appending with Logback</li><li>SMTP appending with Log4j 2</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><ul><li>Spring Boot 3.0.0 M1 Release Notes : <a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0.0-M1-Release-Notes">https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0.0-M1-Release-Notes</a></li><li>Spring Boot 3.0.0 M2 Release Notes : <a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0.0-M2-Release-Notes">https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0.0-M2-Release-Notes</a></li><li>Upgrading to Spring Framework 6.x : <a href="https://github.com/spring-projects/spring-framework/wiki/Upgrading-to-Spring-Framework-6.x">https://github.com/spring-projects/spring-framework/wiki/Upgrading-to-Spring-Framework-6.x</a></li><li>Spring Framework v6.0.0-M1 : <a href="https://github.com/spring-projects/spring-framework/releases/tag/v6.0.0-M1">https://github.com/spring-projects/spring-framework/releases/tag/v6.0.0-M1</a></li><li>Spring Framework v6.0.0-M2 : <a href="https://github.com/spring-projects/spring-framework/releases/tag/v6.0.0-M2">https://github.com/spring-projects/spring-framework/releases/tag/v6.0.0-M2</a></li><li>Spring Framework 6 将使用 Java 17 和 Jakarta EE 9 作为基线版本 : <a href="https://www.infoq.cn/article/4JBuzJI4sbFdoYHfF3h8">https://www.infoq.cn/article/4JBuzJI4sbFdoYHfF3h8</a></li><li>Java 近期新闻综述 : <a href="https://www.infoq.cn/article/1c0wxeozk33n3ki36gzb">https://www.infoq.cn/article/1c0wxeozk33n3ki36gzb</a></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下使用Nginx配置正向代理</title>
      <link href="/2022/02/27/centos8-pei-zhi-nginx-zheng-xiang-dai-li/"/>
      <url>/2022/02/27/centos8-pei-zhi-nginx-zheng-xiang-dai-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux下使用Nginx配置正向代理"><a href="#Linux下使用Nginx配置正向代理" class="headerlink" title="Linux下使用Nginx配置正向代理"></a>Linux下使用Nginx配置正向代理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx 除了用于搭建反向代理, 负载均衡, 也可以用于搭建正向代理服务器</p><p>正向代理的作用有: </p><ul><li><p>内网服务器访问外网</p></li><li><p>提供 VPN 服务</p></li></ul><h2 id="物料准备"><a href="#物料准备" class="headerlink" title="物料准备"></a>物料准备</h2><p>本文使用环境为 CentOS8 , nginx 原生不直接支持https代理, <code>使用 ngx_http_proxy_connect_module</code> 实现 https 代理</p><ul><li>nginx (此处使用1.19.2) : <a href="http://nginx.org/download/nginx-1.19.2.tar.gz">http://nginx.org/download/nginx-1.19.2.tar.gz</a></li><li>nginx 1.19.2 对应 https 模块 : <a href="https://github.com/chobits/ngx_http_proxy_connect_module/archive/refs/tags/v0.0.2.zip">https://github.com/chobits/ngx_http_proxy_connect_module/archive/refs/tags/v0.0.2.zip</a></li><li>gcc cpp 编译器</li><li>pcre-devel 与 openssl-devel</li></ul><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><ol><li><p>切换到 nginx 安装目录 <code>cd /opt/nginx</code></p></li><li><p>下载模块 <code>wget https://github.com/chobits/ngx_http_proxy_connect_module/archive/refs/tags/v0.0.2.zip</code></p></li><li><p>解压 <code>unzip v0.0.2.zip</code> </p></li><li><p>下载 nginx <code>wget http://nginx.org/download/nginx-1.19.2.tar.gz</code></p></li><li><p>打入https模块</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar xf nginx-1.19.2.tar.gzcd nginx-1.19.2patch -p1 &lt; &#x2F;opt&#x2F;nginx&#x2F;ngx_http_proxy_connect_module-0.0.2&#x2F;patch&#x2F;proxy_connect_rewrite_1018.patch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>安装 pcre-devel 与 openssl-devel <code>yum -y install pcre-devel openssl openssl-devel</code></p></li><li><p>安装gcc编译器, 编译安装 nginx </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y install gcc cmake make cmake unzip ncurses-devel gcc gcc-c++.&#x2F;configure --prefix&#x3D;&#x2F;opt&#x2F;nginx&#x2F;nginx_app --add-module&#x3D;&#x2F;opt&#x2F;nginx&#x2F;ngx_http_proxy_connect_module-0.0.2make &amp;&amp; make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>配置 nginx</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;opt&#x2F;nginx&#x2F;nginx_app&#x2F;conf&#x2F;vim nginx.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">server &#123;       listen                           1270;  #自定义正向代理使用端口       server_name                      luoluo;#自定义正向代理服务名称       # dns resolver used by forward proxying    # 域名解析服务器       resolver                         114.114.114.114;       # forward proxy for CONNECT request       proxy_connect;       # 允许端口，all所有, 此处 80 表示 http 请求所需端口, 443 表示 https       proxy_connect_allow              443 80;       proxy_connect_connect_timeout    10s;       proxy_connect_read_timeout       10s;       proxy_connect_send_timeout       10s;       location / &#123;           proxy_pass $scheme://$http_host$request_uri;       &#125;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编写 <code>systemd</code>  启动服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;nginx.service &lt;&lt; EOF[Unit]Description&#x3D;The NGINX HTTP and reverse proxy serverAfter&#x3D;syslog.target network-online.target remote-fs.target nss-lookup.targetWants&#x3D;network-online.target[Service]Type&#x3D;forkingPIDFile&#x3D;&#x2F;opt&#x2F;nginx&#x2F;nginx_app&#x2F;logs&#x2F;nginx.pidExecStartPre&#x3D;&#x2F;opt&#x2F;nginx&#x2F;nginx_app&#x2F;sbin&#x2F;nginx -tExecStart&#x3D;&#x2F;opt&#x2F;nginx&#x2F;nginx_app&#x2F;sbin&#x2F;nginxExecReload&#x3D;&#x2F;opt&#x2F;nginx&#x2F;nginx_app&#x2F;sbin&#x2F;nginx -s reloadExecStop&#x3D;&#x2F;bin&#x2F;kill -s QUIT $MAINPIDPrivateTmp&#x3D;true[Install]WantedBy&#x3D;multi-user.targetEOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>启动 nginx 服务</p><pre class="line-numbers language-bach" data-language="bach"><code class="language-bach">systemctl daemon-reloadsystemctl start nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>开放防火墙对应端口</p></li></ol><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="限定-IP-访问"><a href="#限定-IP-访问" class="headerlink" title="限定 IP 访问"></a>限定 IP 访问</h3><p>在 <code>nginx.conf</code> 的 <code>server&#123;&#125;</code> 中添加配置</p><ol><li><p>仅允许 123.123.123.123 访问</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">allow 123.123.123.123deny all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>仅禁止 123.123.123.123 访问</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">deny 123.123.123.123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>仅允许 123.123.123.1-254 网段访问</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">allow 123.123.123.1/24deny all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>仅禁止 123.123.123.1-254 网段访问</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">deny 123.123.123.1/24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>重新加载配置文件 <code>nginx -s reload</code> (或重启服务)</p></li></ol><h3 id="限定-用户名-x2F-密码-访问"><a href="#限定-用户名-x2F-密码-访问" class="headerlink" title="限定 用户名&#x2F;密码 访问"></a>限定 用户名&#x2F;密码 访问</h3><ol><li><p>安装 apacha-htpasswd<br><code>yum install httpd-tools -y</code></p></li><li><p>生成用户名密码 <code>htpasswd -bc 文件路径 用户名 密码</code><br>e.g. <code>htpasswd -bc /opt/nginx/psd root 123456</code></p></li><li><p>在 <code>nginx.conf</code> 的 <code>server&#123;&#125;</code> 中添加配置</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">auth_basic "input password";   # 这里是提示信息auth_basic_user_file /opt/nginx/psd; # 这里填写刚才生成的文件路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>重新加载配置文件 <code>nginx -s reload</code> (或重启服务)</p></li></ol><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul><li>LNMP高版本脚本编译安装的nginx默认支持ipv6, 所以不必纠结nginx -V查看的结果是否有“–with-ipv6”, 如果使用 “–with-ipv6” 参数, 会报 warning :<br><code>./configure: warning: the “–with-ipv6” option is deprecated</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> nginx </tag>
            
            <tag> centos </tag>
            
            <tag> proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写一个Java注解与 AOP</title>
      <link href="/2021/10/31/xie-yi-ge-java-zhu-jie-yu-aop/"/>
      <url>/2021/10/31/xie-yi-ge-java-zhu-jie-yu-aop/</url>
      
        <content type="html"><![CDATA[<h1 id="写一个-Java-注解与-AOP"><a href="#写一个-Java-注解与-AOP" class="headerlink" title="写一个 Java 注解与 AOP"></a>写一个 Java 注解与 AOP</h1><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解: 用在其他注解上的注解</p><p>四种元注解: </p><ul><li>@Target : 描述注解的使用范围</li><li>@Retention : 描述注解的生命周期</li><li>@Documented : 将此注解包含在Javadoc中</li><li>@Inherited : 使被它修饰的注解具有继承性</li></ul><h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>描述注解的可使用范围 (取值范围在 java.lang.annotation.ElementType.java 中)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123;    &#x2F;**     * Returns an array of the kinds of elements an annotation type     * can be applied to.     * @return an array of the kinds of elements an annotation type     * can be applied to     *&#x2F;    ElementType[] value();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ElementType :</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public enum ElementType &#123;    &#x2F;** Class, interface (including annotation type), or enum declaration *&#x2F;    TYPE,&#x2F;&#x2F;类，接口（包括注解类型）或枚举的声明    &#x2F;** Field declaration (includes enum constants) *&#x2F;    FIELD,&#x2F;&#x2F;属性的声明    &#x2F;** Method declaration *&#x2F;    METHOD,&#x2F;&#x2F;方法的声明    &#x2F;** Formal parameter declaration *&#x2F;    PARAMETER,&#x2F;&#x2F;方法形式参数声明    &#x2F;** Constructor declaration *&#x2F;    CONSTRUCTOR,&#x2F;&#x2F;构造方法的声明    &#x2F;** Local variable declaration *&#x2F;    LOCAL_VARIABLE,&#x2F;&#x2F;局部变量声明    &#x2F;** Annotation type declaration *&#x2F;    ANNOTATION_TYPE,&#x2F;&#x2F;注解类型声明    &#x2F;** Package declaration *&#x2F;    PACKAGE,&#x2F;&#x2F;包的声明    &#x2F;**     * Type parameter declaration     *     * @since 1.8     *&#x2F;    TYPE_PARAMETER,    &#x2F;**     * Use of a type     *     * @since 1.8     *&#x2F;    TYPE_USE&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Retetion"><a href="#Retetion" class="headerlink" title="@Retetion"></a>@Retetion</h3><p>限定注解使用在其他类后, 可以保留到什么时候 (取值定义在 java.lang.annotation.RetentionPolicy.java 中)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123;    &#x2F;**     * Returns the retention policy.     * @return the retention policy     *&#x2F;    RetentionPolicy value();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RetentionPolicy : </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public enum RetentionPolicy &#123;    &#x2F;**     * Annotations are to be discarded by the compiler.     *&#x2F;    SOURCE,&#x2F;&#x2F;源文件保留(javac把.java源文件编译成.class时，就将相应的注解去掉), 只在编译时用到, 编译后无意义    &#x2F;**     * Annotations are to be recorded in the class file by the compiler     * but need not be retained by the VM at run time.  This is the default     * behavior.     *&#x2F;    CLASS,&#x2F;&#x2F;编译期保留(注解被保留到class文件，但jvm加载class文件时候被遗弃), 是默认值    &#x2F;**     * Annotations are to be recorded in the class file by the compiler and     * retained by the VM at run time, so they may be read reflectively.     *     * @see java.lang.reflect.AnnotatedElement     *&#x2F;    RUNTIME&#x2F;&#x2F;运行期保留, 自定义注解一般都用这个&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p>将此注解包含在Javadoc中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>如果某个类使用了被@Inherited修饰的注解，则其子类将自动具有该注解</p><ul><li>仅对 @Target(ElementType.ANNOTATION_TYPE) 的注解有效</li><li>仅对 class 的继承 (对 interface 的继承无效)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="自定义一个注解"><a href="#自定义一个注解" class="headerlink" title="自定义一个注解"></a>自定义一个注解</h2><h3 id="通过反射获取注解"><a href="#通过反射获取注解" class="headerlink" title="通过反射获取注解"></a>通过反射获取注解</h3><p>反射 : 程序在运行期可以拿到一个对象的所有信息; 通过 Class 实例获取 class 信息<br>        使程序在运行期对某实例一无所知的情况下, 调用它的方法</p><h4 id="定义一个注解"><a href="#定义一个注解" class="headerlink" title="定义一个注解"></a>定义一个注解</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.company;import java.lang.annotation.*;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documented@Inheritedpublic @interface Painter &#123;    String occupation() default &quot;&quot;;    String twitter() default &quot;&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="定义一个实体类"><a href="#定义一个实体类" class="headerlink" title="定义一个实体类"></a>定义一个实体类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.company;public class Painters &#123;    @Painter(occupation &#x3D; &quot;幼术师&quot;, twitter &#x3D; &quot;@shiratamacaron&quot;)    private String shiratama &#x3D; &quot;shiratama&quot;;    @Painter(twitter &#x3D; &quot;@xdeyuix&quot;)    private Integer deyui &#x3D; 1220;    private String yusano &#x3D; &quot;yusano&quot;;    public String getShiratama() &#123;        return shiratama;    &#125;    public void setShiratama(String shiratama) &#123;        this.shiratama &#x3D; shiratama;    &#125;    public Integer getDeyui() &#123;        return deyui;    &#125;    public void setDeyui(Integer deyui) &#123;        this.deyui &#x3D; deyui;    &#125;    public String getYusano() &#123;        return yusano;    &#125;    public void setYusano(String yusano) &#123;        this.yusano &#x3D; yusano;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="通过反射获取注解与字段值"><a href="#通过反射获取注解与字段值" class="headerlink" title="通过反射获取注解与字段值"></a>通过反射获取注解与字段值</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.company;import java.lang.reflect.Field;public class Main &#123;    public static void main(String[] args) throws Exception&#123;        &#x2F;&#x2F;创建类模板        Class&lt;?&gt; c &#x3D; Class.forName(&quot;com.company.Painters&quot;);        &#x2F;&#x2F;创建类的实例        Object object &#x3D; c.newInstance();        &#x2F;&#x2F;获取所有字段        for (Field f : c.getDeclaredFields()) &#123;            f.setAccessible(true);      &#x2F;&#x2F;设置字段可访问, 否则无法访问private字段, f.get 时报错 IllegalAccessException            System.out.println(&quot;当前字段&quot; + f.getName());&#x2F;&#x2F;输出当前字段            &#x2F;&#x2F;判断这个字段是否有Painter注解            if (f.isAnnotationPresent(Painter.class)) &#123;                Painter annotation &#x3D; f.getAnnotation(Painter.class);                System.out.println(&quot; 有@Painter注解&quot; +                            &quot;        职业: &quot;  + annotation.occupation() +                            &quot;        推特: &quot;  + annotation.twitter() +                            &quot;        值: &quot;    + f.get(object));            &#125; else &#123;                System.out.println((&quot; 无@Painter注解&quot; + &quot;          值: &quot; + f.get(object)));            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果 : </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">当前字段shiratama 有@Painter注解        职业: 幼术师        推特: @shiratamacaron        值: shiratama当前字段deyui 有@Painter注解        职业:         推特: @xdeyuix        值: 1220当前字段yusano 无@Painter注解          值: yusano<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注解与-Spring-AOP"><a href="#注解与-Spring-AOP" class="headerlink" title="注解与 Spring AOP"></a>注解与 Spring AOP</h3><p>在日志中print一点东西…..<del>再修改一下返回值)咕了</del></p><h4 id="引入-Spring-AOP-依赖"><a href="#引入-Spring-AOP-依赖" class="headerlink" title="引入 Spring AOP 依赖"></a>引入 Spring AOP 依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-aop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注解类"><a href="#注解类" class="headerlink" title="注解类"></a>注解类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documented@Inheritedpublic @interface GetPainterInfo &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="切面类-更多见注释"><a href="#切面类-更多见注释" class="headerlink" title="切面类 (更多见注释)"></a>切面类 (更多见注释)</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Aspect     &#x2F;&#x2F;声明是切面类@Component  &#x2F;&#x2F;声明是组件类, 注册bean到Spring容器中public class PainterAspect &#123;    &#x2F;&#x2F;@Pointcut 表示这是一个切点    &#x2F;&#x2F;@annotation 表示此切点切到一个注解上, 之后是该注解的全类名    @Pointcut(&quot;@annotation(com.example.demo.GetPainterInfo)&quot;)    public void painterPointCut()&#123;&#125;    &#x2F;&#x2F;环绕通知, 表示在painterPointCut(即@Painter注解的方法)前后做一点事情    @Around(&quot;painterPointCut()&quot;)    public Object painterAround(ProceedingJoinPoint joinPoint)&#123;        &#x2F;&#x2F;获取方法的名称        String methodName &#x3D; joinPoint.getSignature().getName();        &#x2F;&#x2F;获取传入参数名称        String[] paramName &#x3D; ( (MethodSignature)joinPoint.getSignature() ).getParameterNames();        &#x2F;&#x2F;获取传入参数值        Object[] param &#x3D; joinPoint.getArgs();        &#x2F;&#x2F;遍历所有参数名称添加到StringBuilder对象中        StringBuilder nameStringBuilder &#x3D; new StringBuilder();        for (String string : paramName) &#123;            nameStringBuilder.append(string + &quot;; &quot;);        &#125;        StringBuilder paramStringBuilder &#x3D; new StringBuilder();        for (Object object : param) &#123;            paramStringBuilder.append(object + &quot;; &quot;);        &#125;        &#x2F;&#x2F;直接print到日志        System.out.println (&quot;进入[&quot;+ methodName + &quot;]方法\n&quot; +                            &quot;参数名称[&quot; + nameStringBuilder + &quot;]\n&quot; +                            &quot;参数值[&quot; + paramStringBuilder + &quot;]&quot;);        try &#123;            &#x2F;&#x2F;执行原方法并获取返回值            Object result &#x3D; joinPoint.proceed();            &#x2F;&#x2F;@Around后原方法的返回会被接管, 此处不返回的话就没有返回值了            return result;        &#125; catch (Throwable e) &#123;            e.printStackTrace();        &#125;        &#x2F;&#x2F;凑数用的返回 ↓↓        return new Object();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果: </p><p><img src="https://cdn.jsdelivr.net/gh/luoshieryi/images@main//markdown/image-20210924010844542.png" alt="image-20210924010844542"><br><img src="https://cdn.jsdelivr.net/gh/luoshieryi/images@main//markdown/image-20210924010955569.png" alt="image-20210924010955569"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> spring </tag>
            
            <tag> reflect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL 中使用 boolean logic 代替 CASE</title>
      <link href="/2021/10/30/sql-zhong-shi-yong-boolean-logic-dai-ti-case/"/>
      <url>/2021/10/30/sql-zhong-shi-yong-boolean-logic-dai-ti-case/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-WHERE-clauses-Avoid-CASE-use-Boolean-logic"><a href="#SQL-WHERE-clauses-Avoid-CASE-use-Boolean-logic" class="headerlink" title="SQL WHERE clauses: Avoid CASE, use Boolean logic"></a>SQL WHERE clauses: Avoid CASE, use Boolean logic</h1><h2 id="Why"><a href="#Why" class="headerlink" title="Why ?"></a>Why ?</h2><ul><li>portable</li><li>easier to read</li><li>❤ efficient</li></ul><h2 id="How"><a href="#How" class="headerlink" title="How ?"></a>How ?</h2><p>First off, when I say “conditional logic”, I am talking about something like this: <code>IF A THEN B</code></p><p>Where A and B are both conditions. For example, in a WHERE clause, you might want to implement a condition like this: <code>IF (@ReturnAll &lt;&gt;1) THEN (EmpID = @EmpID)</code></p><p>In other words, if the @ReturnAll parameter is 1, then return all of the rows, but if @ReturnAll is not 1, then only return rows where EmpID is equal to the @EmpID parameter supplied.</p><p>To express this logic in the WHERE clause, many people might code it like this:</p><p><code>WHERE EmpID = CASE WHEN @ReturnAll&lt;&gt;1 THEN @EmpID ELSE EmpID END</code></p><p>However, this is kind of counter-intuitive (why should we check that EmpID &#x3D; EmpID ?) and can be really tough to implement when the condition spans more than 1 column in the table (you need multiple CASE’s). Also, if EmpID is null this will fail.</p><p>The alternative is to translate the condition into a regular boolean expression using only AND, OR and NOT. The logical translation of “IF A then B” is: <code>(Not A) or B</code></p><p>If you work it out on paper, you will see it makes sense. To translate our WHERE clause requirement using the above logic, it becomes: <code>WHERE (@ReturnAll =1) OR (EmpID = @EmpID)</code></p><h2 id="More-examples"><a href="#More-examples" class="headerlink" title="More examples"></a>More examples</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>Suppose we wish to say: <code>IF @Filter=1 THEN Date= @Date and Cust= @Cust and Emp= @Emp</code></p><p>Expressing this in a CASE clause results in:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">WHERE Date &#x3D; CASE WHEN @Filter&#x3D;1 THEN @Date ELSE Date END ANDCust &#x3D; CASE WHEN @Filter&#x3D;1 THEN @Cust ELSE Cust END ANDEmp &#x3D; CASE WHEN @Filter&#x3D;1 THEN @Emp ELSE Emp END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>A little hard to read and quite inefficient – all 3 case expressions must be evaluated for each row in the result set. Without CASE, we get: <code>WHERE @Filter&lt;&gt;1 OR (Date= @Date and Cust= @Cust and Emp= @Emp)</code></p><p>Much easier to read and maintain, and faster – if @Filter &lt;&gt;1, the rest of the expression can be ignored by the optimizer. </p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>Using a single variable to implement the optional filter. For example: <code>IF @CustID is not null THEN CustID = @CustID</code></p><p>This is often implemented using ISNULL() or COALESCE() like this: <code>WHERE CustID = ISNULL(@CustID, CustID)</code></p><p>This is basically the same as writing a CASE expression in that it will not use an index on our column and doesn’t implement solid boolean logic. </p><p>Converting that IF to a simple boolean expression results in a nice WHERE clause of: <code>WHERE (@CustID is null OR CustID = @CustID)</code></p><p>Which, again, is the preferred way to implement this type of logic in SQL.  It is short, simple, portable, easy to read and maintain, and efficient.</p><h2 id="Finally"><a href="#Finally" class="headerlink" title="Finally,"></a>Finally,</h2><p>To express: <code>IF A THEN B ELSE C</code><br>You would write it as: <code>((Not A) or B) AND (A or C)</code></p><p>A little harder, but it does the job! No need for CASE in the WHERE clause</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://weblogs.sqlteam.com/jeffs/2003/11/14/513/">SQL WHERE clauses: Avoid CASE, use Boolean logic</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 异常处理</title>
      <link href="/2021/10/18/java-yi-chang-chu-li/"/>
      <url>/2021/10/18/java-yi-chang-chu-li/</url>
      
        <content type="html"><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="try-catch-finally-的调用顺序"><a href="#try-catch-finally-的调用顺序" class="headerlink" title="try-catch-finally 的调用顺序"></a>try-catch-finally 的调用顺序</h2><p>try 中未抛出异常则不执行 catch 中的方法<br>即使 try 或 catch 中有 return 语句仍会执行 finally 中的语句, 且 finally 中的 return 会覆盖 try\catch 的return</p><h2 id="test方法"><a href="#test方法" class="headerlink" title="test方法"></a>test方法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.company;public class tryCatchFinally &#123;    public String test(int a) &#123;        try &#123;            System.out.print(&quot;try\t\t&quot;);            throw new Exception();        &#125; catch (Exception e) &#123;            System.out.print(&quot;catch\t\t&quot;);            return &quot;catch&quot;;        &#125; finally &#123;            System.out.print(&quot;finally\t\t&quot;);            if (a &#x3D;&#x3D; 1) &#123;                return &quot;finally&quot;;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main方法 (逃) </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Main &#123;    public static void main(String[] args) throws Exception&#123;        System.out.println( Class.forName(&quot;com.company.tryCatchFinally&quot;).getDeclaredMethod(&quot;test&quot;, int.class).invoke(Class.forName(&quot;com.company.tryCatchFinally&quot;).newInstance(), 1) );        System.out.println( Class.forName(&quot;com.company.tryCatchFinally&quot;).getDeclaredMethod(&quot;test&quot;, int.class).invoke(Class.forName(&quot;com.company.tryCatchFinally&quot;).newInstance(), 0) );    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">trycatchfinallyfinallytrycatchfinallycatch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> error </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 多线程</title>
      <link href="/2021/10/13/java-duo-xian-cheng/"/>
      <url>/2021/10/13/java-duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>多线程实际上并不是同时执行, 多个任务在极短时间内交替执行, 由于 CPU 运算速度很快, 所以看起来像是同时执行</li></ul><p>线程与进程: </p><ul><li>在计算机中的一个任务称为一个进程, 一个进程包含一至多个线程</li><li>运行程序时, 可以使用: 多进程+单线程, 单进程+多线程, 多进程+多线程</li><li>进程的特点: 创建时的开销更大, 不同进程间数据通信慢, 稳定性更高(一个进程奔溃不影响其他进程运行)</li></ul><p>多线程: 一个 Java 程序其实是一个 JVM 进程, JVM 进程中有一个 main 主线程, 我们在 main 中执行各种方法, 启动多个线程</p><h2 id="创建一个新线程"><a href="#创建一个新线程" class="headerlink" title="创建一个新线程"></a>创建一个新线程</h2><p>创建一个新线程, 需要实例化一个<code>Thread</code>实例, 调用它的<code>start()</code>方法, 之后<code>start()</code>方法会自动调用这个实例的<code>run()</code>方法, 启动线程</p><p>三种创建线程的方法: <code>implements Runnable</code> , <code>extends Thread</code> , 使用Callable和Future</p><ul><li>区别: 实现 Runnable 与 Callable 接口后可以继承其他类, 继承 Thread 类在一些操作上更简单</li></ul><p><code>extends Thread</code>示例: </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class horseRun extends Thread &#123;    public static final int LENGTH &#x3D; 188;    char c;    horseRun(char c) &#123;        this.c &#x3D; c;  &#125;    @Override    public void run() &#123;        for (int i &#x3D; 0; i &lt; LENGTH; i ++) &#123;            System.out.print(c);        &#125;    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Thread horse1 &#x3D; new horseRun(&#39;%&#39;);        Thread horse2 &#x3D; new horseRun(&#39;$&#39;);        horse1.start();        horse2.start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出: <code>$$$$$$$$$$$$$$$$$$$$%%%%%%%%%%%%%%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$%%%%%%%%%%%%%%%%%%$$$$$$$$$$$$%%%%</code></p><ul><li>每次的结果都不一样, 两个线程同时开始运行, 由<strong>操作系统进行调度, 程序无法决定</strong></li></ul><p>尝试修改进程的优先级: <code>horse1.setPriority(4); horse2.setPriority(6);</code><br>输出结果: <code>$$$$$%%%$$$$$$$%%%%%%$$$$$$$$%%%%$$$$$$$%%%$$$$$$$$$$$$$$$$$$$$$$$%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</code></p><ul><li>操作系统可能对高优先级线程调度更频繁, 但是并不能保证线程一定会先执行</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java访问权限修饰符</title>
      <link href="/2021/09/21/java-lei-cheng-yuan-de-si-chong-fang-wen-quan-xian/"/>
      <url>/2021/09/21/java-lei-cheng-yuan-de-si-chong-fang-wen-quan-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h1><p>Java 为 类、属性字段、方法 提供了四种访问权限 : default, public, private, protected</p><h2 id="default-friendly-包访问权限"><a href="#default-friendly-包访问权限" class="headerlink" title="default (friendly) - 包访问权限"></a>default (friendly) - 包访问权限</h2><blockquote><p>是默认访问权限, 没有任何关键字</p></blockquote><p>Java 中不声明任何访问权限修饰符则默认为此, 包内其他成员可访问</p><ul><li>其他包的子类不可见</li><li>若两个类存放在同一个目录下且没有设定包名称, Java 自动将它们看作隶属于该目录的默认包中</li></ul><h2 id="public-接口访问权限"><a href="#public-接口访问权限" class="headerlink" title="public - 接口访问权限"></a>public - 接口访问权限</h2><p>对任何人都可访问</p><h2 id="private-无法访问"><a href="#private-无法访问" class="headerlink" title="private - 无法访问"></a>private - 无法访问</h2><p>任何其他类无法访问</p><ul><li>子类不可见</li></ul><h2 id="protected-继承访问权限"><a href="#protected-继承访问权限" class="headerlink" title="protected - 继承访问权限"></a>protected - 继承访问权限</h2><p>相同包可见, 子类可见</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2021/09/10/mysql-bi-ji/"/>
      <url>/2021/09/10/mysql-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="初识09-06"><a href="#初识09-06" class="headerlink" title="初识09.06"></a>初识<del>09.06</del></h1><h2 id="数据库术语"><a href="#数据库术语" class="headerlink" title="数据库术语"></a>数据库术语</h2><ul><li>数据库 database : 保存有组织的数据的容器</li><li>表 table : 某种特定类型数据的结构化清单<ul><li>相同数据库不能使用相同表名</li></ul></li><li>模式 schema : 关于数据库和表的布局及特性的信息 (有时用作数据库的同义词)</li><li>列 column : 表中的一个字段<ul><li>表由一个或多个列组成</li></ul></li><li>数据类型 datatype : 所容许的数据的类型</li><li>行 row : 表中的一个记录</li><li>主键 primary key :  一列（或一组列），其值能够唯一区分表 中每个行<ul><li>任意两行主键值不同 (一组列时, 所有列值的组合唯一)</li><li>每行都有主键值(不允许NULL)</li><li>好习惯 : <ul><li>不更新主键列中的值</li><li>不重用主键列的值</li><li>不在主键列中使用可能会更改的值</li></ul></li></ul></li><li>外键 foreign key : 某个表中的一列, 它包含另一个表的主键值, 定义了两个表之间的关系 <ul><li>列名可以与原主键不同, 数据类型要相同</li></ul></li></ul><h2 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h2><p>sequel是结构化查询语言 Structured Query Language 的缩写, 一种专门用来与数据库通信的语言</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL是一种DBMS, 即一种数据库软件</p><h1 id="使用MySQL"><a href="#使用MySQL" class="headerlink" title="使用MySQL"></a>使用MySQL</h1><p>选择数据库: <code>USE 数据库名</code></p><p>返回可用数据库列表: SHOW DATABASES</p><ul><li>包含MySQL内部使用的数据库</li></ul><p><code>SHOW</code> : 查看数据库, 表和内部信息</p><h1 id="检索数据-SELECT09-08"><a href="#检索数据-SELECT09-08" class="headerlink" title="检索数据-SELECT09.08"></a>检索数据-SELECT<del>09.08</del></h1><h2 id="SELECT基础"><a href="#SELECT基础" class="headerlink" title="SELECT基础"></a>SELECT基础</h2><p><code>SELECT 列名 FROM 表名</code></p><ul><li>SQL语句应以 ; 分隔\结束</li><li>SQL语句不区分大小写, 但是推荐大写</li><li>SQL语句中的所有空格都被忽略</li></ul><p>检索多个列: <code>SELECT 列名,列名 FROM 表名</code></p><p>检索所有列: <code>SELECT * FROM 表名</code></p><ul><li>这样可以检索未知列</li></ul><p>只检索具有不同值的列表: <code>SELECT DISTINCT 列名 FROM 表名</code></p><p>限制不多于五行: <code>SELECT 列名 FROM 表名 LIMIT 5</code><br>返回从第四行开始的五行: <code>SELECT 列名 FROM 表名 LIMIT 4,5</code> , 同义于<code>SELECT 列名 FROM 表名 LIMIT 5 OFFSET 4</code></p><ul><li>检索出来的<strong>第一行是行0</strong></li></ul><p>使用完全限定的列名, 表名: <code>SELECT 表名.列名 FROM 连接名.表名</code></p><h2 id="排序检索数据-ORDER-BY"><a href="#排序检索数据-ORDER-BY" class="headerlink" title="排序检索数据-ORDER BY"></a>排序检索数据-ORDER BY</h2><ul><li>如果不排序, 数据一般以它在底层表中出现的顺序显示 (更新或删除后会受到影响)</li></ul><p>使用 OREDR BY : <code>SELECT 列名1 FROM 表名 ORDER BY 列名2</code></p><ul><li>可以用<code>,</code>分隔以多列排序</li><li>默认以升序排序(ASC), 在列名后附加<code> DESC</code>指定该列以降序排序</li></ul><h2 id="条件过滤数据-WHERE"><a href="#条件过滤数据-WHERE" class="headerlink" title="条件过滤数据-WHERE"></a>条件过滤数据-WHERE</h2><p>使用 WHERE : <code>SELECT 列名1 FROM 表名 WHERE 条件</code></p><ul><li><strong><code>ORDER BY</code>应位于<code>WHERE</code>之后</strong></li><li>WHERE 支持的子句操作符: &#x3D;, &lt;&gt;(不等于), !&#x3D;(不等于), &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, BETWEEN(在指定的两个数据之间</li><li>字符串以单引号括住, 数字不需要</li><li>BETWEEN 示例: <code>SELECT 列名1 FROM 表名 WHERE 列名2 BETWEEN 数值a AND 数值b</code><ul><li>BETWEEN 的范围是&gt;&#x3D;a , &lt;&#x3D;b</li></ul></li><li>空值检查: <code>WHERE 列名 IS NULL</code><ul><li>不匹配搜索(使用不等号)不会返回具有NULL值的行</li></ul></li></ul><p>组合 WHERE 语句, 使用AND, OR : <code>WHERE 条件1 AND 条件2</code></p><ul><li>AND 的优先级比 OR 高, 需要使用圆括号正确组合操作符</li></ul><p>通过 IN 指定条件范围: <code>WHERE 列名 IN (值1, 值2)</code></p><ul><li>IN 比等效的 OR 执行更快</li><li>IN 可以包含其他 SELECT 语句</li></ul><p>通过 NOT 否定后跟条件的关键字: <code>WHERE 列名 NOT IN (值1, 值2)</code></p><ul><li>MySQL支持 NOT 对IN, BETWEEN, EXISTS取反</li><li>NOT 只否定后边紧跟的一个条件</li></ul><p>通过 LIKE 使用通配符: <code>WHERE 列名 LIKE &#39;jet%&#39;</code> , 找出所有词以jet起头的内容</p><ul><li>通配符 % 表示任意字符出现任意次数(包括0个字符), 此处即接受jet后的任意字符<ul><li><code>LIKE &#39;%&#39;</code>不能匹配NULL</li></ul></li><li>通配符可以在任意位置出现任意次</li><li>通配符 _ 只匹配单个字符, 不包括0个字符</li><li>通配符运行效率较差, 尽量使用其他语句<br>使用多个条件搜索时应当将通配符相关的搜索条件放在靠后执行的位置</li></ul><h3 id="正则表达式-REGEXP"><a href="#正则表达式-REGEXP" class="headerlink" title="正则表达式-REGEXP"></a>正则表达式-REGEXP</h3><p>REGEXP 后所跟的东西作为正则表达式</p><ul><li>例: <code>WHERE 列名 REGEXP &#39;1000&#39;</code>, 检索列中包含文本 1000 的所有行</li><li><code>.</code>是正则表达式语言中一个特殊的字符, 表示匹配任意一个字符</li><li>默认不区分大小写, 使用<code>BINARY</code>关键字区分大小写</li></ul><p>OR 匹配: <code>WHERE 列名 REGEXP &#39;1000 | 2000 | 3000&#39;</code></p><p>[] 匹配一组字符中的任意一个: <code>REGEXP [123]000</code>, 等效上一句</p><ul><li><code>[^123]</code>匹配除1, 2, 3以外的任何内容</li><li><code>[0-9]</code>匹配 0~9 任意数字</li></ul><p>特殊匹配规则:</p><ul><li><p>匹配”-“与”.”等特殊字符: 使用\为前导, 进行转义 <code>\\-</code> </p></li><li><p><code>\\ </code>也用来引用元字符: 如<code>\\n</code>表示换行</p></li><li><p>匹配字符类: 如<code>[:alnum:]</code>表示任意字母和数字, 同<code>[a-zA-Z0-9]</code></p></li></ul><p>匹配多个实例: 默认只对其前边的一个字符有效</p><ul><li><code>*</code> : 0个或多个匹配</li><li><code>+</code> : 1个或多个匹配, 等于<code>&#123;1, &#125;</code></li><li><code>?</code> : 0个或一个匹配, 等于 <code>&#123;0,1&#125;</code></li><li><code>&#123;数值&#125;</code> : 指定数目的匹配</li><li><code>&#123;数值, &#125;</code> : 不少于指定数目的匹配</li><li><code>&#123;数值1, 数值2&#125;</code> : 匹配数目的范围 (数值2不超过255)</li><li>示例: <ol><li><code>REGEXP &#39;\\([0-9] sticks?\\)&#39;</code> : 此句中 ? 使最后的 s 成为可选字符, 有没有s都会被检出, 有其他字符不会</li><li><code>REGEXP &#39;[[:digit:]]&#123;4&#125;</code> : 匹配连在一起的任意四位数字, 等效于<code>&#39;[0-9][0-9][0-9][0-9]&#39;</code></li></ol></li></ul><p>匹配特定位置的文本: </p><ul><li><code>^</code> : 文本的开始</li><li><code>$</code> : 文本的结尾</li><li><code>[[:&lt;:]]</code> : 词的开始</li><li><code>[[:&gt;:]]</code> : 词的结尾</li><li>示例: <code>REGEXP &#39;^[0-9\\.]</code> 在 . 或任意数字为串中第一个字符时匹配</li><li>通过^开始每个表达式, $结束每个表达式, 可以使REGEXP的作用与LIKE一样</li></ul><h2 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h2><p>字段: 基本与 列 相同</p><p>Concat()函数 拼接: 将值连在一起构成单个值</p><ul><li>示例: <code>SELECT Concat(列名1, &#39; (&#39;, 列名2, &#39;)&#39;)</code><br>会输出<code>值1 (值2)</code></li><li>Concat 的多个串以”,”分隔</li></ul><p>删除数据多余的空格: Trim()函数</p><ul><li><code>RTrim(列名)</code>去掉值右边的空格</li><li><code>LTrim(列名)</code>去掉值左边的空格</li><li><code>Trim(列名)</code>去掉左右两边的空格</li></ul><p>AS 使用别名: 新计算的列没有名字无法引用, 赋予别名解决这个问题</p><ul><li>示例: <code>SELECT Concat(列名1, &#39; (&#39;, 列名2, &#39;)&#39;) AS 别名</code></li><li>在原名不合法时重命名它, 易误解时扩充它</li><li>别名也称导出列</li></ul><p>计算: 支持 +, -, *, &#x2F; 四个基本操作运算符, 可用圆括号区分优先顺序</p><ul><li>示例: <code>SELECT 列名1 + 列名2 AS 别名</code></li></ul><h2 id="数据处理函数"><a href="#数据处理函数" class="headerlink" title="数据处理函数"></a>数据处理函数</h2><p><em>函数的可移植性较差, 使用时建议做好注释</em></p><p>文本处理函数:</p><ul><li>示例 <code>WHERE Soundex(列名) = Soundex(&#39;Lie&#39;)</code>, 匹配发音与Lie类似的值(如Lee)</li></ul><p>日期和时间处理函数:</p><ul><li>日期格式应为 <code>yyyy-mm-dd</code></li><li>基本日期条件过滤: <code>WHERE 列名 = &#39;yyyy-mm-dd&#39;</code><ul><li>默认具体时间为<code>00:00:00</code>, 如果表中值为<code>yyyy-mm-dd 11:30:05</code>不会匹配</li><li>使用Date()函数, 仅比较给出的日期(即只比较<code>yyyy-mm-dd</code>), 相应的Time函数只比较时间: <code>WHERE Date(列名) = &#39;yyyy-mm-dd&#39;</code></li><li>使用Year(), Month()等只返回年份, 月份</li></ul></li></ul><p>数值处理函数: 一般用于代数, 三角或几何运算</p><h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><blockquote><p>有时返回具体数据是对时间和资源的浪费</p></blockquote><p>SQL的五个聚集函数:</p><table border="2">    <tr>        <th>函数</th>        <td>AVG()</td>        <td>COUNT()</td>        <td>MAX()</td>        <td>MIN()</td>        <td>SUM()</td>    </tr>    <tr>        <th>功能</th>        <td>平均值</td>        <td>行数</td>        <td>最大值</td>        <td>最小值</td>        <td>总和</td>    </tr></table>AVG() : `SELECT AVG(列名) AS 别名 FROM 表名` , 得到这一列的平均值<p>COUNT() : </p><ul><li><code>SELECT COUNT(*)</code> : 对表中包括空值的所有行计数</li><li><code>COUNT(列名)</code> : 对特定列中具有值的行计数, 不计算NULL</li></ul><p>MAX() 与 MIN() 与 SUM() : 要求指定列名, 会忽略NULL</p><p>**使用<code>DISTINCT</code>参数, 只考虑不同的内容: **</p><ul><li>示例: <code>AVG(DISTINCT 列名)</code>, 计算平均值时只取不同的值</li><li>必须指定列名</li><li><em>有一个对应的参数<code>ALL</code>, 是没什么用的默认值</em></li></ul><p>组合聚集参数: 使用”,”隔开不同语句, 可以换行好看些</p><h2 id="分组数据-GROUP-BY09-09"><a href="#分组数据-GROUP-BY09-09" class="headerlink" title="分组数据-GROUP BY09.09"></a>分组数据-GROUP BY<del>09.09</del></h2><p>把数据分成多个逻辑组, 以便对每个组进行聚集计算</p><ul><li><p>示例: <code>SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id</code><br>输出: <img src="https://raw.githubusercontent.com/luoshieryi/images/main/markdown/image-20210909130806621.png" alt="image-20210909130806621"></p></li><li><p>GROUP BY子句可以包含任意数目的列, 使得可以通过对分组嵌套达到更细致的控制</p></li><li><p>GROUP BY子句中不能使用别名, 若在 SELECT 中使用表达式, GROUP BY 子句中须指定相同的表达式</p></li><li><p>除聚集计算语句外, SELECT 中每个列都需要在GROUP BY 子句中给出</p></li><li><p>一个或多个NULL值也会被分为一组</p></li><li><p><strong>GROUP BY 子句应在 WHERE 之后, ORDER BY 之前</strong></p></li><li><p><strong>使用 GROUP BY 子句时, 应当给出 ORDER BY 子句保证正确排序</strong></p></li><li><p>后边附加<code>WITH ROLLUP</code>, 可以获得所有分组汇总的值</p></li></ul><h3 id="过滤分组-HAVING"><a href="#过滤分组-HAVING" class="headerlink" title="过滤分组-HAVING"></a>过滤分组-HAVING</h3><p>HAVING 非常类似于 WHERE (WHERE 在分组前进行过滤, HAVING 在分组后进行过滤)</p><ul><li>示例: <code>SELECT cust_id, COUNT(*) AS orders FROM orders GROUP BY cust_id HAVING COUNT(*) &gt;=2</code><br>过滤两个以上的 COUNT(*) 的分组</li><li>不能使用别名</li><li><strong>HAVING支持所有WHERE操作符</strong></li></ul><h2 id="SELECT-子句顺序"><a href="#SELECT-子句顺序" class="headerlink" title="SELECT 子句顺序"></a>SELECT 子句顺序</h2><p>SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY → LIMIT</p><h2 id="子查询-嵌套"><a href="#子查询-嵌套" class="headerlink" title="子查询-嵌套"></a>子查询-嵌套</h2><p>嵌套在其他查询中的查询 : 将一条 SELECT 语句返回的结果用于另一条 SELECT 语句的 WHERE 子句</p><ul><li><a name="子查询1">示例</a>:</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT cust_name, cust_contactFROM customersWHERE cust_id IN (SELECT cust_id                  FROM orders                  WHERE order_num IN (SELECT order_num                                      FROM orderitems                                      WHERE prod_id &#x3D;&#39;TNT2&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>上边的例子在性能上不一定是最好的, <a href="#%E8%81%94%E7%BB%93%E6%9F%A5%E8%AF%A21">之后的联结查询</a>会给出一个更好的方法</li><li>子查询一般与 IN 操作符结合使用, 也可以用 &#x3D;, &lt;&gt; 等</li><li>作为计算字段使用子查询示例:<ul><li>这里嵌套内的 WHERE 使用了完全限定列名, 告诉 SQL 比较 orders 表中的 cust_id 与当前正从customers 表中检索的 cust_id</li><li>这种称为相关子查询, 只要列名可能有多义性, 就必须使用这种语法</li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT cust_name, cust_state, (SELECT COUNT(*)        FROM orders        WHERE orders.cust_id &#x3D; customers.cust_id) AS ordersFROM customersORDER BY cust_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>建议先用硬编码数据建立和测试外层查询, 并且仅在确认它正常后才嵌入子查询</p></blockquote><h2 id="联结表-划重点"><a href="#联结表-划重点" class="headerlink" title="联结表(划重点)"></a>联结表(划重点)</h2><p>联结是一种机制, 用来在一条 SELECT 语句中关联表, 可以联结多个表返回一组输出</p><ul><li><p><a name="示例-联结表1">示例</a>: </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT vend_name, prod_name, prod_priceFROM vendors, productsWHERE vendors.vend.id &#x3D; products.vend.idORDER BY vend_name, prod_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里三个列分别在两个表中, 通过 WHERE 语句正确联结两个表, 需要完全限定列名</p></li><li><p>没有联结条件的表关系返回结果为笛卡尔积, 检索出的行数是第一个表中行数乘以第二个表中行数</p></li><li><p>叉联结是一种笛卡尔积的联结类型</p></li></ul><h3 id="内部联结-等值联结"><a href="#内部联结-等值联结" class="headerlink" title="内部联结(等值联结)"></a>内部联结(等值联结)</h3><p>即<a href="#%E7%A4%BA%E4%BE%8B-%E8%81%94%E7%BB%93%E8%A1%A81">上边示例</a>的联结方式, 可以这样明确指定联结的类型:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT vend_name, prod_name, prod_priceFROM vendors INNER JOIN productsON vendors.vend_id &#x3D; products.vend.id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>联结条件用特定的 ON 子句而不是 WHERE 子句给出</p><h3 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h3><p>联结太多表性能下降会很严重</p><p><a name="联结查询1">示例1</a>: 使用联结查询优化<a href="#%E5%AD%90%E6%9F%A5%E8%AF%A21">上边的子查询</a></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT cust_name, cust_contactFROM customers, orders, orderitemsWHERE customers.cust_id &#x3D; orders.cust_idAND orderitems.order_num &#x3D; orders.order_numAND prod_id&#x3D;&#39;TNT2&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高级联结"><a href="#高级联结" class="headerlink" title="高级联结"></a>高级联结</h3><h4 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h4><ul><li>缩短SQL语句</li><li><strong>允许在单条 SELECT 语句中多次使用相同的表</strong> <code>FROM employee AS a, employee AS b</code></li></ul><h4 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h4><p>以下两种解决方案结果相同, 第二种自联结方式效率高于第一种子查询</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT prod_id, prod_nameFROM productsWHERE vend_id &#x3D; (SELECT vend_id                 FROM products                WHERE prod_id &#x3D; &#39;DTNTR&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT p1.prod_id, p1.prod_nameFROM products AS p1, products AS p2WHERE p1.vend_id &#x3D; p2.vend_idAND p2.prod_id &#x3D; &#39;DTNTR&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h4><p>自然联结排除多次出现, 使每个列只返回一次</p><ul><li>需要自己手动完成</li></ul><h4 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h4><p>包含了在相关表中没有关联行的行</p><ul><li><p>必须使用 RIGHT 或 LEFT 关键字指定包括其所有行的表 (包括OUTER JOIN 右边或左边的表) , 即从右边或左边表中选择所有行</p></li><li><p>内部, 外部联结的区别示例|<br><img src="https://raw.githubusercontent.com/luoshieryi/images/main/markdown/image-20210909183350173.png" alt="image-20210909183350173"><img src="https://raw.githubusercontent.com/luoshieryi/images/main/markdown/image-20210909183441236.png" alt="image-20210909183441236"></p></li></ul><h4 id="带聚集函数的联结"><a href="#带聚集函数的联结" class="headerlink" title="带聚集函数的联结"></a>带聚集函数的联结</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT customers.cust_name, customers.cust_id, COUNT(orders.order_num) AS num_ordFROM customers LEFT OUTER JOIN ordersON customers.cust_id &#x3D; orders.cust_idGROUP BY customers.cust_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="组合查询-UNION"><a href="#组合查询-UNION" class="headerlink" title="组合查询-UNION"></a>组合查询-UNION</h2><p>组合使用多条 SELECT 语句, 等效于具有多个 WHERE 子句的单条 SELECT 语句. 两种查询性能优劣不一定</p><p>通过在各 SELECT 语句之间加入 UNION 实现</p><ul><li>示例:</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt; 5UNIONSELECT vend_id, prod_id, prod_priceFROM productsWHERE vend_id IN (1001,1002);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等效于</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt;&#x3D; 5OR vend_id IN (1001,1002);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>UNION 中的每个查询必须包含相同的列, 表达式或聚集函数, 顺序可以不同</li><li>UNION 从查询结果集中自动去除重复的行<ul><li>使用 UNION ALL 返回不去重的全部行 (此时必须使用 UNION 而不能 WHERE)</li></ul></li><li>组合查询可以应用于不同的表</li></ul><h3 id="对组合查询结果排序"><a href="#对组合查询结果排序" class="headerlink" title="对组合查询结果排序"></a>对组合查询结果排序</h3><p>使用 UNION 时, 只能使用一条 ORDER BY 语句, 出现在最后一条 SELECT 之后,</p><h2 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h2><p><em>并非所有引擎都支持全文本搜索</em>‘</p><p>对指定列中各词创建一个索引, 针对这些词进行搜索.</p><ul><li>为进行全文本搜索, 必须索引被搜索的列, 且随着数据的改变不断进行索引(自动进行)</li><li>索引后, SELECT 可与 Match() 和 Against() 一起使用执行搜索</li></ul><p>全文本搜索的优点:</p><ul><li>性能更好</li><li>明确控制</li><li>智能化的结果</li></ul><p>启用全文本搜索支持: 在创建表时通过 FULLTEXT 子句, 示例如下</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE productnotes(    note_idintNOT NULL AUTO_INCREMENT,    prod_idchar(10)NOT NULL,    note_datedatetimeNOT NULL,    note_texttextNULL,    PRIMARY KEY(note_id),    FULLTEXT(note_text))ENGING&#x3D;MyISAM<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这里根据<code>FULLTEXT(note_text)</code>对note_text进行索引</li><li>定义之后, MySQL会自动维护索引</li></ul><p>进行全文本搜索: 使用<code>Match()</code>和<code>Against()</code>两个函数进行全文本搜索, 其中Match()指定被搜索的列, Against()指定要使用的搜索表达式, 示例如下</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT note_textFROM productnotesWHERE Match(note_text) Against(&#39;rabbit&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等效于</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT note_textFROM productnotesWHERE note_text LIKE &#39;%rabbit%&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>指定 rabbit 作为搜索文本, 搜索 note_text 列中包含 rabbit 的行</li><li>前者以文本匹配良好程度排序的数据, 后者以不特别有用的顺序返回数据</li></ul><p>注意事项: </p><ul><li><p>传递给 Match() 的值必须与 FULLTEXT() 中定义的相同, 多个列时必须列出他们且次序正确</p></li><li><p>搜索默认不区分大小写 (除非使用 BINARY 方式)</p></li><li><p>指定多个搜索项时, 包含多数匹配词的行将具有更高的等级值</p></li></ul><h3 id="使用查询扩展"><a href="#使用查询扩展" class="headerlink" title="使用查询扩展"></a>使用查询扩展</h3><p>流程: <code>Against(&#39;值&#39; WITH QUERY EXPANSION)</code></p><ol><li>先进行一个基本的全文本搜索, 找出与搜索条件匹配的所有行</li><li>MySQL 检查这些匹配行并选择有用的词</li><li>再次进行全文本搜索, 使用原来的词 + 有用的词</li></ol><h3 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h3><p>以布尔方式, 提供如下关于内容的细节: </p><ul><li>要匹配的词</li><li>要排斥的词</li><li>排列提示(指定某些词比其他词更重要)</li><li>表达式分组</li><li>另外一些内容</li></ul><p><em>即使没有FULLTEXT也可以使用布尔方式, 但会非常缓慢</em></p><p>示例: <code>WHERE Match(note_text) Against(&#39;heavy -rope*&#39; IN BOOLEAN MODE)</code></p><ul><li><code>-rope*</code>指示排除包含rope*的词(以rope开始的词)</li><li><img src="https://raw.githubusercontent.com/luoshieryi/images/main/markdown/image-20210910205020402.png" alt="image-20210910205020402"></li></ul><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><blockquote><ul><li>在索引全文本数据时，短词被忽略且从索引中排除。短词定义为 那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。</li><li>MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参 阅MySQL文档以了解如何完成此工作）。</li><li>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEAN MODE。</li><li>如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词 或者不出现，或者至少出现在50%的行中）。</li><li>忽略词中的单引号。例如，don’t索引为dont。</li><li>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。</li><li>如前所述，仅在MyISAM数据库引擎中支持全文本搜索。</li></ul></blockquote><h1 id="插入-x2F-更新-x2F-删除09-10"><a href="#插入-x2F-更新-x2F-删除09-10" class="headerlink" title="插入&#x2F;更新&#x2F;删除09.10"></a>插入&#x2F;更新&#x2F;删除<del>09.10</del></h1><h2 id="插入数据-INSERT"><a href="#插入数据-INSERT" class="headerlink" title="插入数据-INSERT"></a>插入数据-INSERT</h2><p>通常方法:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT INTO 表1VALUES(NULL,      &#39;值1&#39;,      &#39;值2&#39;,      NULL,      &#39;值3&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>插入一个新内容到表1中, 按照表中列的顺序输入</li><li>若某一列没有值, 需要使用NULL(允许的话)</li></ul><p>更安全的方法:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT INTO 表2(列名1,              列名2,              列名3)              VALUES(&#39;值1&#39;,                     NULL,                     &#39;值2&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在表名后给出列名, 与之后的值顺序对应</li><li>不需要提供值的列直接不写出列名 (NO NULL且没有默认值(如自增值)的必须赋值)</li></ul><p>插入多行: 同时使用以”;”分隔的多条 INSERT 语句或者单条 INSERT 有多组值(更快)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT INTO 表3(列名1,               列名2)               VALUES(                   &#39;值1&#39;,                   &#39;值2&#39;               ),               (                   &#39;值3&#39;,                   &#39;值4&#39;               );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>插入检索出的数据:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT INTO 表4(列1,               列2)               SELECT 列3,                 列4               FROM 表5;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="更新数据-UPDATE"><a href="#更新数据-UPDATE" class="headerlink" title="更新数据-UPDATE"></a>更新数据-UPDATE</h2><p>示例:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">UPDATE 表1SET 列1 &#x3D; &#39;值1&#39;,列2 &#x3D; &#39;值2&#39;WHERE 条件1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用 WHERE 限定要更新的行, 不然它会更新所有行</li><li>更新时如果出现错误, 则整个UPDATE操作被取消, 使用<code>UPDATE IGNORE 表1</code>, 即使发生错误也继续更新</li><li>通过<code>SET 列1 = NULL</code>删去某列的值(假设允许NULL)</li></ul><h2 id="删除数据-DELETE"><a href="#删除数据-DELETE" class="headerlink" title="删除数据-DELETE"></a>删除数据-DELETE</h2><p>示例:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DELETE FROM 表2WHERE 条件2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>删除指定条件的行<ul><li>删除指定的列使用UPDATE</li></ul></li><li>不使用WHERE会删除全部行</li></ul><p>删除表中所有行使用 TRUNCATE TABLE 更快(删除原来的表并重新创建一个)</p><p><strong>更新&#x2F;删除前应现用 SELECT 对 WHERE 条件进行测试</strong></p><h1 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h1><h2 id="创建表-CREATE"><a href="#创建表-CREATE" class="headerlink" title="创建表-CREATE"></a>创建表-CREATE</h2><p>使用交互式工具, 或直接使用MySQL语句</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE customers(    cust_id int NOT NULL AUTO_INCREMENT,    cust_name char(50) NOT NULL,    cust_address char(50) NULL,  cust_numintNOT NULL DEFAULT 1,    PREMARY KEY (cust_id)) ENGINE&#x3D;InnoDB;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用<code>PREMARY KEY (列1, 列2)</code>指定主键, 主键不能有 NULL 与重复值</li><li>使用<code>NOT NULL</code>指定不允许 NULL , 否则默认为允许</li><li>使用<code>AUTO_INCREMENT</code>指定对该列自动增量<ul><li><code>SELECT last_insert_id</code>返回最后一个 AUTO_INCREMENT 值</li></ul></li><li>使用<code>DEFAULT 值1</code>指定默认值</li><li>使用<code>ENGINE=引擎名</code>指定引擎类型, 不指定时使用默认引擎<ul><li><code>InnoDB</code> : 不支持全文本搜索, 可靠的事务处理引擎</li><li><code>MEMORY</code> : 数据存储在内存中, 速度很快, 适合临时表, 功能等同于 <code>MyISAM</code></li><li><code>MyISAM</code> : 性能极高, 支持全文本搜索, 不支持事务处理</li><li><strong>外键不能跨引擎</strong>, 引擎混用的缺点</li></ul></li></ul><h2 id="更新表-ALTER"><a href="#更新表-ALTER" class="headerlink" title="更新表-ALTER"></a>更新表-ALTER</h2><p>理想状态下不应当更新表, 常见用途是定义外键</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE 表名1ADD 列名1 数据类型1; -- 添加列1DROP COLUMN 列名2; -- 删除列2ADD CONSTRAINT 外键约束名 FOREIGN KEY (列名3)-- 添加外键REFERENCES 表名2 (列名4)ADD CONSTRAINT fk_products_vendors FOREIGN KEY (vend_id)-- 添加外键示例REFERENCES vendors (vend_id)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除表-DROP"><a href="#删除表-DROP" class="headerlink" title="删除表-DROP"></a>删除表-DROP</h2><p><code>DROP TABLE 表名</code>, 没有确认, 不能撤销</p><h2 id="重命名表-RENAME"><a href="#重命名表-RENAME" class="headerlink" title="重命名表-RENAME"></a>重命名表-RENAME</h2><p><code>RENAME TABLE 表名1 TO 表名2</code>, 可以同时对多个表重命名</p><h1 id="其他功能09-11"><a href="#其他功能09-11" class="headerlink" title="其他功能09.11"></a>其他功能<del>09.11</del></h1><h2 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h2><p>视图示例① : 简化复杂的联结</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE VIEW productcustomers ASSELECT cust_name, cust_contact, prod_idFROM customers, orders, orderitemsWHERE customers.cust_id &#x3D; order.cust_idAND orderitems.order_num &#x3D; orders.order_num;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>创建了一个名为 <code>productcutomers</code> 的视图, 联结三个表, 返回其中的三列</li><li>使用 <code>SELECT * FROM productcutomers</code> 返回这个视图的三列</li></ul><p>视图示例② : 重新格式化检索出的数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE VIEW vendorlocations ASSELECT Concat(RTrim(vend_name), &#39;(&#39;, RTrim(vend_country), &#39;)&#39;)AS vend_titleFROM vendorsORDER BY vend_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>之后使用 <code>SELECT * FROM vendorlocations;</code> 即可实现</li></ul><p>视图的用处:</p><ul><li>重用 SQL 语句</li><li>简化复杂的 SQL 操作</li><li>仅使用表的部分组成, 保护数据</li><li>更改数据格式和表示</li></ul><p>注意点:</p><ul><li>视图不包含任何数据, 它包含的是一个 SQL 查询</li><li>使用视图相当于执行检索, 过于复杂或嵌套过多的视图性能会下降严重</li><li>视图必须唯一命名(与表一样)</li><li>使用视图时的 ORDER BY 会覆盖视图内部的 ORDER BY</li><li>视图可以与表同时使用</li><li>视图不能索引</li></ul><p>更新视图: 对视图使用 INSERT, UPDATE, DELETE</p><ul><li>更新视图其实是更新其基表</li><li>若要更新的基数据不能被确定, 则无法更新, 即视图定义中有以下操作: 分组, 联结, 子查询, 并, 聚集函数( Min(), Count(), Sum() )等, DISTINCT, 导出列</li><li>视图应用于检索而不是更新</li></ul><h2 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h2><p>为以后的使用保存一条或多条MySQL语句的集合</p><p>用处 :</p><ul><li>把处理封装, 简化复杂的操作</li><li>保证所有开发人员使用的代码相同(同一存储过程), 防止错误</li><li>简化对变动的管理 (使用存储过程的人员不需要知道这些变化)</li></ul><p>优点 : 简单, 安全, 高性能</p><ul><li>性能更好, 使用存储过程比单独的 SQL 语句更快</li><li>用 一些只能用在单个请求中的MySQL元素和特性 编写功能更强更灵活的代码 <a href="#%E6%99%BA%E8%83%BD%E5%AD%98%E5%82%A8%E7%A4%BA%E4%BE%8B1">示例</a></li></ul><p>缺陷 : 编写时 更困难,需要安全访问权限 (编写与执行存储过程的权限是分开的)</p><h3 id="执行存储过程-调用"><a href="#执行存储过程-调用" class="headerlink" title="执行存储过程-调用"></a>执行存储过程-<a name="调用存储过程1">调用</a></h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CALL productpricing(@pricelow,                   @pricehigh,                   @priceaverage);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>通过 <code>@pricelow</code> 等向存储过程传递参数</li><li>所以MySQL变量都必须以 @ 开始</li><li>该语句不显示任何值, 使用 <code>SELECT @pricelow, @pricehigh;</code> 调用变量</li></ul><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE PROCEDURE productpricing()BEGINSELECT Ave(prod_price) AS priceaverageFROM products;END;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>创建名为 <code>productpricing</code> 的存储过程</li><li>若存储过程接受参数, 在名称后的 () 中列出</li><li>通过 <code>CALL productpricing()</code> 调用这个存储过程</li></ul><p>使用命令行实用程序时需要更改分隔符, <code>DELIMITER //</code> 告诉它使用&#x2F;&#x2F;作为新的语句结束分隔符, 语句结束时再使用 <code>DELIMITER ;</code> 换回去</p><h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><p><code>DROP PROCEDURE productpricing</code></p><ul><li>删除时没有后面的 () </li><li>若过程不存在会返回一个错误, 使用 <code>DROP PROCEDURE IF EXISTS</code> 不会产生错误</li></ul><h3 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h3><p>一般存储过程不显示结果, 而是把结果返回给变量</p><ul><li>变量: 内存中一个特定的位置, 用来临时存储数据,</li></ul><p>示例 1 :</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREAT PROCEDURE productpricing(OUT p1 DECIMAL(8, 2),  OUT ph DECIMAL(8, 2),  OUT pa DECIMAL(8, 2))BEGINSELECT Min(prod_price)INTO p1FROM products;SELECT Max(prod_price)INTO phFROM products;SELECT Avg(prod_price)INTO paFROM products;END;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>此过程接受三个参数: p1存储产品最低价, ph存储最高价, pa存储平均价</li><li>每个参数必须指定类型, 这里用  DECIMAL 指定十进制, (8, 2) 指定小数点左侧最多 8 位, 右侧最多 2 位. (右侧最多为8)</li><li>记录集是不允许的类型, 所以不能通过一个参数返回多行列, 此处要使用三个参数</li><li>通过<a href="#%E8%B0%83%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B1">此处示例</a>调用此过程</li></ul><p>示例 2 :</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE PROCEDURE ordertotal(IN onumber INT,  OUT ototal DECIMAL(8, 2))BEGINSELECT Sum(item_price * quantity)FROM orderitemsWHERE order_num &#x3D; onumberINTO ototal;END;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用 IN 表示要输入的数据</li><li>示例调用 <code>CALL ordertotal(20005, @total)</code></li></ul><h3 id="建立智能存储"><a href="#建立智能存储" class="headerlink" title="建立智能存储"></a>建立智能存储</h3><p>在存储过程内包含业务规则和智能处理, <a name="智能存储示例1">智能存储示例</a>:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- Name: ordertotal-- Parameters: onumber &#x3D; order number-- taxable &#x3D; 0 ifnot taxable, 1 if taxable-- ototal &#x3D; order total variableCREATE PROCEDURE ordertotal(IN onumber INT,  IN taxable BOOLEAN,  OUT ototal DECIMAL(8, 2)) COMMENT &#39;Obtain order total, optionally adding tax&#39;BEGIN-- Declare variable for totalDECLARE total DECIMAL(8, 2);-- Declare tax percentageDECLARE taxrate INT DEFAULT 6;-- Get the order totalSELECT Sum(item_price*quantity)FROM orderitemsWHERE order_num &#x3D; onumberINTO total;-- Is this taxable?IF taxable THEN-- Yes, so add taxrate to the totalSELECT total+(total&#x2F;100*taxrate) INTO total;END IF;-- And finally, save to out variableSELECT total INTO ototal;END;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>前边放置 – 增加注释</p></li><li><p>使用 DECLARE 声明两个局部变量</p></li><li><p>若增加营业税, 则输入 taxable 为真, 执行之后的 SELECT , 并将结果存储到局部变量 total</p></li><li><p>最后用一句 SELECT 将 total 保存到 ototal</p></li><li><p>COMMENT 添加一个解释, 会在 SHOW PROCEDURE STATUS 的结果中显示</p></li><li><p>使用 <code>CALL ordertotal(20005, 0, @total);</code> 使用这个过程</p></li></ul><h3 id="检查存储过程"><a href="#检查存储过程" class="headerlink" title="检查存储过程"></a>检查存储过程</h3><p>显示用来创建一个存储过程的CREATE语句: <code>SHOW CREATE PROCEDURE ordertotal;</code> </p><p>显示何时何人创建等详细信息: <code>SHOW PROCEDURE STATUS</code>, 信息太多可以使用 LIKE 过滤</p><h2 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h2><p><del><em>不怎么用得到…过一下看一眼</em></del></p><p><em>咕了</em></p><h2 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h2><p><em>同上</em></p><h2 id="管理事务处理"><a href="#管理事务处理" class="headerlink" title="管理事务处理"></a>管理事务处理</h2><p>事务处理是一种机制, 用来管理必须成批执行的 MySQL 操作</p><ul><li>用来维护数据库的完整性, 保证成批的 MySQL 操作要么完全执行, 要么完全不执行</li><li>显示事务处理需要所用数据引擎支持</li></ul><p>相关名词:</p><ul><li>事务: 一组 SQL 语句</li><li>回退: 撤销指定 SQL 语句的过程</li><li>提交: 将未存储的 SQL 语句结果写入数据库表</li><li>保留点: 事务处理中设置的临时占位符, 可以对它发布回退(不同于回退整个事务处理)</li></ul><p>使用 <code>START TRANSACTION</code>; 标识事务的开始</p><p>使用 <code>ROLLBACK</code> 回退 START TRANSACTION 之后的所有语句</p><ul><li>不能回退 CREATE 或 DROP 操作</li><li>使用后事务会自动关闭</li></ul><p>使用 <code>COMMIT</code> 提交 START TRANSACTION 之后的所有语句</p><ul><li>一般情况语句会自动隐式提交, 事务处理时语句需要手动提交</li><li>如果前边的语句出错, COMMIT 不会提交</li><li>使用后事务会自动关闭</li></ul><p>使用 <code>SAVEPOINT 保留点1</code>; 创建保留点, 支持回退部分事务处理</p><ul><li><p>使用 <code>ROLLBACK TO 保留点1;</code> 回退到指定位置</p></li><li><p>保留点在事务处理完成后自动释放 (执行一条 ROLLBACK 或 COMNMIT)</p></li></ul><h3 id="使用-SET-autocommit-0-取消默认提交"><a href="#使用-SET-autocommit-0-取消默认提交" class="headerlink" title="使用 SET autocommit=0 取消默认提交"></a>使用 <code>SET autocommit=0</code> 取消默认提交</h3><ul><li>该标志针对每个连接而不是服务器</li></ul><h2 id="字符集和校对顺序"><a href="#字符集和校对顺序" class="headerlink" title="字符集和校对顺序"></a>字符集和校对顺序</h2><p>字符集: 字母和符号的集合</p><p>编码: 某个字符集成员的内部表示</p><p>校对: 规定字符如何比较的指令</p><p>使用 <code>SHOW CHARACTER SET;</code> 显示所有可用的字符集以及每个字符集的描述和默认校对</p><p>使用 <code>SHOW COLLATION;</code> 查看所支持校对的完整列表以及它们适用的字符集</p><ul><li>许多校对出现两次, 一次区分大小写(以 <code>_cs</code> 表示), 一次不区分大小写(以 <code>_ci</code> 表示)</li></ul><p>给表指定字符集和校对: 在 <code>CREATE TABLE()</code> 语句后附加 <code>DEFAULT CHARACTER SET 字符集1 COLLATE 校对1;</code></p><p>还支持给某个列指定字符集和校对, </p><p>也支持在 SELLECT 语句末 <code>COLLATE 校对2</code>指定校对 (用于临时区分大小写)</p><h2 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h2><p>创建用户, 管理用户权限等</p><h2 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h2><p>备份数据, 数据库维护, 诊断启动问题, 查看日志文件等</p><p>事务处理</p><p>设置保留点</p><p>中途出错回退到保留点</p><p>之后的语句呢?</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修图&amp;嵌字功能笔记</title>
      <link href="/2021/09/04/xiu-tu-qian-zi-bi-ji/"/>
      <url>/2021/09/04/xiu-tu-qian-zi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h2><p>每次PS崩溃后，都要重新检查一遍颜色设置-工作空间-灰色gaama2.2（与windows的默认显示器灰度系数相同的等价灰度）</p><p>嵌字段落设置: 行间距自动, 字符比例间距0%, 不要自动加粗, AA方式选择平滑, 对齐中自动行距125(背景字部分135)</p><p>复制图层为非背景层方便对比</p><h2 id="修图"><a href="#修图" class="headerlink" title="修图"></a>修图</h2><p><strong>某个滤镜解决不了的时候 就要去尝试用别的滤镜 不同滤镜各自有各自的特长</strong></p><p>碰到TIFF文件格式就要首先想到索引模式! 遇到索引模式的图应该果断先转灰度模式。然后该干啥干啥。</p><p>ps在保存jpg格式的图时，当品质小于7时，会执行”降色采样”的附加操作，因此不要保存品质低于6的jpg图，一般建议保存为8。</p><p>JPEG不适用于所含颜色较少、具有大块颜色相近的区域或亮度差异十分明显的较简单的图片。</p><p>做了切片之后，可以用”存储为web所用格式”的方法将这些切片保存为不同的文件。”另存为”不可。<br><em>诶….说起来这个几乎没用到过还</em></p><p>自动调整曲线（自动颜色校正）：算法-命令</p><p>增强单色对比度-自动对比度：统一修剪所有通道。可以使高光显得更亮而阴影显得更暗的同时保留整体色调关系。</p><p>增强每通道对比度-自动色调：使每个通道中的色调范围最大化以产生更显著的校正效果。因为各通道是单独调整，所以可能会消除或引入色痕。</p><p>查找深色与浅色-自动颜色：查找图像中平均最亮和最暗的像素，并使用它们来使对比度最大化，同时使修剪最小化。</p><p>对齐中性中间调-自动颜色：查找图像中平均接近的中性色，然后调整灰度系数（中间调）值使颜色成为中性色。</p><p>修图尺寸：1.推荐用原图尺寸修</p><p>2.如果原图存在细密网纹，用滤镜除不掉，就缩小图片应该可以解决</p><p>3.坚决不建议缩得太小，那样子容错率太低</p><p>你的衣服和肤色差距比较大，可以试一下色相饱和度这个图层，尝试下只改某个颜色</p><p>肤色的话，大部分时候都是红色，偶尔是黄色。不知道你要改的地方是什么色的话，就直接点一下预设下面的按钮，然后取样，他会自动匹配相应的颜色</p><h3 id="工具的使用情况"><a href="#工具的使用情况" class="headerlink" title="工具的使用情况"></a>工具的使用情况</h3><h4 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h4><ul><li>消除细网点: 小心重复过高斯模糊 → Noiseware → td6 → 表面模糊</li><li>消除太过锐利的感觉</li><li>消除锯齿</li><li>消除白噪</li></ul><h2 id="嵌字"><a href="#嵌字" class="headerlink" title="嵌字"></a>嵌字</h2><p>标点符号: 与该行居中对齐, 单独拿出来调整或者改变它的基线偏移</p><p>[使用中文标点]{.ul}, 排列格式需要与原图相同</p><p>双破折号栅格化补全空白</p><p>英文字母：字母较少时标准垂直罗马对齐，较多时普通格式</p><p>描边: 先描灰边便于修图, 修好后改回白边</p><p>空心字: 白色字黑描边</p><p>立体字: 栅格化-自由变换-右键扭曲</p><p>自由路径文字: 用标尺拉出原文本底部的最高低点, 以这些点为锚点用钢笔画曲线, 在曲线上用文字工具, 按ESC键隐藏路径</p><p>栅格化文字在自由变换会边缘发虚, 需要锐化</p><p>网点图的制作: 新建大尺寸灰度图(800*800), 填充为灰度127附近的灰色, 图像-模式-位图,</p><p><strong>常用快捷键</strong></p><p>D 背景色设置为黑色, 前景色设置为白色</p><p>ctrl+M打开曲线的调整窗口</p><p>Ctrl+1 图片放大到100%</p><p>Ctrl+0 图片缩放到适合屏幕</p><p>Space+左键拖动放大后的图片</p><p>ctrl+Y切换RGB&#x2F;CMYK预览模式（RGB超出CMYK太多要考虑重新调色或丢弃一些太明亮的颜色，或者以CMYK图为背景层，用RGB图覆盖，调整RGB图的透明度）</p><p>ctrl+alt+N 新建图层</p><p>ctrl+U 调节色相、饱和度</p><p>ctrl+R 出现标尺，拉参考线</p><p>ctrl+K 调节参考线（打开首选项）</p><p>ctrl+shift+j 文本两端对齐</p><p>V 移动工具</p><p>ctrl+shift+N 新建图层</p><p>ctrl+alt+I 调整图像大小（分辨率）</p><p><img src="https://raw.githubusercontent.com/luoshieryi/images/main/markdown/image-20210906171925636.png" alt="image-20210906171925636"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ps </tag>
            
            <tag> memo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
